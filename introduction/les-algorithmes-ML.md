## Apprendre les définitions

Déjà le commencement, psuique lorsque l'on parle de `data`, il y a de suite trois termes qui prennent le dessus et sont de suite évoqués. Nous allons les détailler afin de idéntifier quels sont leurs cas d'application.  

**La Business Intelligence (BI)** est une méthode d'analyse de données qui permet aux entreprises de collecter, stocker, analyser et visualiser des données afin de prendre des décisions éclairées. Elle utilise des outils tels que les tableaux de bord, les rapports et les analyses pour aider les entreprises à comprendre leur performance et à identifier les tendances.  

**Le Machine Learning (ML)** est une branche de l'intelligence artificielle qui utilise des algorithmes pour apprendre à partir de données et améliorer les performances d'une tâche sans être explicitement programmé. Il est utilisé dans de nombreux domaines, tels que la reconnaissance vocale, la reconnaissance d'images et la détection de fraudes.  

**Intelligence Artificielle** est une discipline de l'informatique qui vise à créer des machines capables d'imiter la créativité et la prise de décision similaire à l'intelligence humaine. Elle utilise des techniques telles que le ML pour apprendre à partir de données et résoudre des problèmes complexes. L'IA est utilisée dans de nombreux domaines, tels que la génération d'images, la traduction automatique et les chatbots.  

#### Alors, comment les distinguer?
La BI est plus orientée vers l'analyse de données historiques, tandis que le ML et l'IA sont plus axés sur l'exploration, la prévision et l'analyse en temps réel. La BI est souvent utilisée pour résoudre des problèmes spécifiques, tandis que le ML est utilisé pour explorer des comportements et l'IA peut être utilisés pour simuler la prise de décision raisonnée.  

Enfin la BI est souvent utilisée pour prendre des décisions opérationnelles, tandis que le ML est souvent utilisés pour prendre des décisions stratégiques et l'IA est utilisée pour automatiser.  

#### Qu'est-ce que je peux faire faire à une IA ?

L'intelligence artificielle (IA) est un domaine vaste et diversifié qui comprend de nombreuses sous-disciplines ou "familles".  

- **Modèles de régression** : Ces modèles sont utilisés pour prédire une valeur continue en fonction des entrées. Par exemple, un modèle de régression pourrait être utilisé pour prédire le prix d'une maison en fonction de sa taille, de son emplacement, de son âge, etc.  
- **Modèles de classification** : Ces modèles sont utilisés pour prédire à quelle catégorie appartient une entrée. Par exemple, un modèle de classification pourrait être utilisé pour prédire si un email est un spam ou non.  
- **Modèles de clustering** : Ces modèles sont utilisés pour regrouper des entrées similaires ensemble. Par exemple, un modèle de clustering pourrait être utilisé pour regrouper des clients en fonction de leurs comportements d'achat.  
- **Modèles génératifs (prédictifs)** : Ces modèles sont utilisés pour générer de nouvelles données qui ressemblent à la distribution des données d'entraînement. Ils sont souvent utilisés pour générer des images, du texte, de la musique, etc.  

Nous allons les aborder tous ces sujets après les autres dans les prochains cours, hormis le Business Intelligence qui est hors de portée pour cette unité d'enseignement.

## Fondements du Machine Learning

### Introduction au Machine Learning

**Machine Learning: Qu'est-ce que c'est?**

Le Machine Learning (ML), ou apprentissage automatique en français, est un sous-ensemble de l'intelligence artificielle qui donne aux ordinateurs la capacité d'apprendre et de s'améliorer à partir de l'expérience sans être explicitement programmés. Imaginez un robot qui apprend à marcher par lui-même en tombant et en se relevant, ajustant chaque fois ses mouvements. De la même manière, en ML, les ordinateurs apprennent à partir de données.

**Les Types de Machine Learning**

Il existe principalement trois types de ML:
1. **Apprentissage Supervisé**: Ici, l'ordinateur apprend à partir de données étiquetées. L'apprentissage supervisé est comme apprendre avec un professeur qui vous donne la bonne réponse après chaque question. Par exemple, si vous apprenez à reconnaître des fruits, le professeur vous montre une pomme et vous dit que c'est une pomme. Vous apprenez ainsi à associer l'image à la bonne étiquette.
3. **Apprentissage Non Supervisé**: Dans ce cas, l'ordinateur apprend à partir de données non étiquetées. Il doit trouver des patterns et des structures par lui-même. L'apprentissage non supervisé est comme apprendre par vous-même sans professeur. Par exemple, si on vous donne un tas de fruits mélangés et qu'on vous demande de les trier, vous devez trouver un moyen de les organiser (par couleur, taille, forme, etc.) sans qu'on vous dise quelle est la bonne réponse.
4. **Apprentissage par Renforcement**: Ici, l'apprentissage se fait par essais et erreurs, et l'ordinateur est récompensé lorsqu'il fait un bon choix. L'apprentissage par renforcement est comme apprendre à jouer à un jeu vidéo sans suivre de tutoriel ni lire le manuel d'instructions. Vous essayez différentes actions, vous voyez ce qui fonctionne et ce qui ne fonctionne pas et vous ajustez votre stratégie en conséquence pour obtenir le meilleur score possible.

### Processus de Machine Learning

**Étapes Clés dans le ML**
1. **\[(E)xtract\] Collecte de Données**: Tout commence par la collecte de données. Comme un chef qui rassemble des ingrédients pour préparer un plat, l'apprentissage automatique nécessite des données pour construire des modèles.
2. **\[(T)ransform\] Prétraitement des Données**: Les données brutes ne sont pas toujours prêtes à l'emploi. Il faut souvent les nettoyer et les organiser, un peu comme éplucher et couper les légumes avant de cuisiner.
3. **\[(L)oad\] Entraînement et validation du Modèle**: C'est ici que l'ordinateur apprend réellement. Les données traitées sont utilisées pour entraîner un modèle. Cela ressemble à un apprenti cuisinier qui apprend à faire un plat en le pratiquant plusieurs fois (et valide son avancement en goûtant detemps en à autre pendant les préparations)
4. **Test du Modèle**: Après l'entraînement, il est important de tester le modèle avec de nouvelles données pour évaluer sa performance. C'est comme faire goûter le plat à quelqu'un pour s'assurer qu'il est bon.
5. **Déploiement**: Une fois le modèle testé et affiné, il est prêt à être utilisé dans des applications réelles. C'est envoyer l'apprenti en cuisine lors du service.

### Applications Pratiques du Machine Learning

**Le ML dans la Vie Quotidienne**
1. **Recommandations de Produits**: Les sites de commerce en ligne utilisent le ML pour recommander des produits. En fonction de vos achats précédents et de votre navigation, ils prédisent ce qui pourrait vous plaire.
2. **Reconnaissance Faciale**: Les smartphones utilisent le ML pour la reconnaissance faciale, permettant de déverrouiller votre téléphone en vous regardant simplement.
3. **Prévision Météorologique**: Les modèles de ML aident à prévoir le temps, analysant d'énormes quantités de données météorologiques pour prédire le temps qu'il fera demain.

### Le dictionnaire de l'IA et du ML

En IA et en ML, on ne parle pas de _generation_ de données mais plutôt de **prédiction**. Quand bien même que l'on parlerait de ChatGPT et lorsqu'il *genère* du texte, en termes techniques nous dirions qu'il est en train de faire une **prédiction** d'un texte mot après mot.  

En informatique et en théorie des algorithmes, les termes utilisés pour catégoriser et décrire les algorithmes peuvent varier en fonction de leurs caractéristiques, de leur complexité et de leur comportement. Tous les algorithmes *prédictifs*, comme ceux basés sur le programmation *dynamique*, le *ML* ou l'*IA*, sont dits des **algorithmes de optimisation**. Ce terme qui peut porter à confusion, est utilisé en opposition aux *algorithmes détérministes* que nous avons vu jusqu'auparavant et dont le résultat (en fonction du temps et de l'éspace nécéssaire à eur execution), finissent toujours par donner un résultat *exact et fini* (c'est à dire détérminé). Lorsqu'on parle de **optimisation**, cela fait généralement référence à la manière dont ces algorithmes ajustent leurs paramètres pour minimiser une *fonction de coût ou de perte*, c'est-à-dire qu'ils s'ajoustent de manière itérative pour améliorer leurs *prédictions* et finissent par donner un résultat **optimal** sans être jamais parfaitement exact.

A la différence des humains qui *observent et déduisent* les règles de fonctionnement pour déviner un résultat *selon leur jugement et déduction*,  les IA **inférent** une prédiction en se basant sur la *probabilité*: il n'y a pas, pour ainsi dire, d'intelligence à proprement parler et aucun concept de comprehénsion.

**Les mots de l'apprentissage**

Ce n'est pas au hasard si le mot choisi en anglais c'est `training` pour cette phase et cela doit encore moins surprendre lorsque le résultat s'appelle `fit`, comme après une session de gym.  
Alors et lors des phases d'apprentissage, le jeu du concepteur de ce système est de faire apprendre à la machine et depuis les données chargées, à généraliser: en d'autres termes, le modèle doit apprendre à faire des prédictions en se basant sur des données qu'il n'aurait pas vu auparavant qui seraient vraisemblables aux données observées précédemment et de la même espèce.  

Lors de la conception d'un modèle de prédiction (ML ou IA), vous pourriez faire face à plusieurs risques qui pourraient compromettre vos résultats, il y a le risque liés à la collecte où vos données ne sont pas representative de la réalité dans la quelle vos prédictions sont censés opérer ou le répresentent trop précisemment laissant pas assez d'éspace pour la généralisation ou alors une representation très variée mais chaque categorie pas suffisemment representée ou une distribution des exemples disponibles entre catégories qui ne serait pas équitable; et il y a les risques liés à l'entrainement où vous pourriez ne pas montrer assez de données et d'avoir des prédiction trop aléatoires ou même pire de trop montrer de données et d'avoir un système incapable de répondre à des données qu'il n'aurait pas déjà vu. Nous abordons les sujets de *biais* et de *variance*, *overfit* et *underfit*.  

- **La Variance** d'un modèle d'apprentissage automatique est sa sensibilité aux fluctuations dans l'ensemble de données d'entraînement. Un modèle avec une grande variance est susceptible de surapprendre les données d'entraînement et de mal se généraliser à de nouvelles données. La variance est comme essayer de juger de la qualité d'un restaurant en fonction d'un seul repas. Si vous avez un excellent repas, vous pourriez penser que le restaurant est toujours excellent, même si ce n'est pas toujours le cas.
- **Le Biais** peut se référer à deux choses: un modèle qui aurait sa tendance à faire des prédictions systématiquement erronées ou les données q ui se produit lorsque l'ensemble de données ne représente pas équitablement toutes les catégories ou caractéristiques d'intérêt. Le biais est comme une balance qui n'est pas correctement calibrée et donne toujours un poids légèrement trop élevé ou trop faible. Ou c'est comme essayer de comprendre ce que les gens pensent en ne demandant l'avis qu'à un petit groupe de personnes.  
- **Le surapprentissage (Overfitting)** se produit lorsqu'un modèle d'apprentissage automatique apprend trop bien les données d'entraînement et ne parvient pas à généraliser à de nouvelles données. Cela se produit souvent lorsque le modèle est trop complexe par rapport à la quantité et à la variété des données disponibles. Le surapprentissage est comme étudier pour un examen en mémorisant toutes les questions et réponses d'un ancien examen. Vous pourriez obtenir un score parfait si l'examen est exactement le même, mais si les questions changent même un peu alors vous risquez de ne pas bien faire.  
- **Le sous-apprentissage (Underfitting)** se produit lorsqu'un modèle d'apprentissage automatique ne parvient pas à apprendre les données d'entraînement. Cela se produit souvent lorsque le modèle est trop simple pour capturer la complexité des données. Le sous-apprentissage est comme essayer de comprendre un livre en ne lisant que le résumé. Vous obtenez une idée générale de l'histoire, mais vous manquez beaucoup de détails et vous risquez de ne pas comprendre certaines parties.  

La sauce secrète d'un entrainement se cache dans le jeu de données calibré à vos besoins, que l'on appelera dorénavant **dataset d'apprentissage** et dans la façon que vous allez laisser votre modèle s'entrainer dessus. Les machines ont besoin d'apprendre par itération, necessitent de comparer l'ensemble de leur base d'apprentissage avec l'ensemble des données à apprendre et de comparer ses résultats avec la réalité pour parvenir à *inférer* les bonnes *probabilités* lors d'une *prédiction*. Ainsi et a différence d'un humain, une seule observation d'une même donnée ne sera pas suffisante et une base d'apprentissage devra être montrée plusieurs fois à différent stades d'apprentissage afin de pouvoir en calculer une base statistique fiable. Vous l'aurez compris, nous abordons ici les paramètres à prendre en compte lors de la phase de *training* qui sont les **époques**, les **batchs** et le **taux d'apprentissage**.

- **Le Taux d'Apprentissage** est un paramètre dans les algorithmes d'optimisation qui détermine la taille des mises à jour apportées aux paramètres du modèle à chaque étape de l'entraînement. Le taux d'apprentissage est comme la vitesse avec la quelle vous traversez une ville sur un week-end pour la visiter: trop rapide, vous aller tout visiter sans retenir que peu; trop lentement et vous n'auriez pas le temps de tout visiter.
- **Un Epoch** est une passe complète à travers l'ensemble de dataset d'apprentissage pendant le processus d'entraînement d'un modèle d'apprentissage automatique. Une epoch est comme un tour complet d'un jeu de société. À la fin de chaque tour (ou epoch), vous avez vu toutes les cartes (ou données) une fois.
- **Un Batch** est un sous-ensemble de l'ensemble de données d'entraînement qui est utilisé pour mettre à jour le modèle dans le processus d'entraînement. La taille du batch est un paramètre important qui peut affecter la vitesse et la qualité de l'entraînement. Un batch est comme une petite pile de cartes que vous utilisez pour jouer à un jeu. Au lieu de jouer avec toutes les cartes en même temps, vous jouez avec une petite pile à la fois.

Mais ce n'est pas tout, parce que et quand bien même vous auriez eu un dataset d'apprentissage équilibré et des paramètres d'apprentissages optimaux, tout n'est pas à réténir pour arriver à une prédiction. Un modèle de ML ou de IA est un algorithme très puissant qui peut arriver à détérminer des correlations entre les données à analyser (vos paramètres d'entrée) qui seraient impossibles à observer à l'oeil nu, cependant tout n'est pas détérminant pour réussir une prédiction. Il existent donc des paramètres qui servent à détérminer quand certaines probabilités sont à prendre en compte ou pas et alors même que ces paramètrent jouent un rôle bienque minime *statistiquement parlant*. Nous abordons les sujets de **function d'activation** et de **fonction de perte** qui rentrent en jeu respectivement lors de la phase d'*prédiction* et de la phase de *entrainement*.

- **La Fonction d'Activation** est une fonction utilisée pour transformer la sortie. Des exemples courants de fonctions d'activation incluent la fonction sigmoïde, la fonction TanH et la fonction ReLU. Une fonction d'activation est comme le déclic que vous ressentez lorsque vous comprenez quelque chose. Elle prend votre pensée floue et la transforme en une idée claire et précise tout en filtrant tout ce qui n'est pas assez clair ou insignifiant.

L'observation que même avec un ensemble de données d'apprentissage bien équilibré et des paramètres d'apprentissage optimisés, tous les éléments de données ne sont pas nécessairement pertinents pour réaliser une prédiction est cruciale en machine learning et en IA: imaginons que vous ayez un ensemble de données sur les étudiants comprenant diverses informations telles que leurs heures d'étude, leurs activités parascolaires, leur alimentation, leurs habitudes de sommeil et même la couleur de leurs cahiers. En entrainant un modèle de ML pour prédire la réussite scolaire, vous pourriez constater que certaines variables, comme les heures d'étude et les habitudes de sommeil, sont fortement corrélées avec de bons résultats scolaires. Cependant, d'autres données, comme la couleur des cahiers, n'ont probablement aucun impact significatif sur la performance académique, bien que l'algorithme puisse détecter une corrélation. Un modèle de ML pourrait identifier une corrélation entre la réussite scolaire et des facteurs apparemment non pertinents, comme la couleur des cahiers. Pour un humain, il est évident que cette corrélation est probablement fortuite ou non causale. Mais un modèle de ML pourrait l'interpréter comme un facteur influent, surtout si par hasard dans les données d'apprentissage, les étudiants performants avaient tendance à utiliser des cahiers de couleur spécifique. En l'absence d'une sélection judicieuse des caractéristiques à prendre en compte, un modèle peut inclure du bruit ou des corrélations non pertinentes conduisant à des prédictions trompeuses. Ainsi, ce genre de bruit peut être filtré grace à une *fonction d'activation* qui ne permettrait pas à des statistiques *insignifiantes* d'être prise en jeu dans le calcul de la *probabilité* d'une certaine *prédiction*.  

Mais comment est-ce que l'influence d'un paramètre sur l'ensemble de l'apprentissage est détérminé? C'est le rôle de la *fonction de perte.

- **La Fonction de Perte** est une fonction qui mesure à quel point les prédictions d'un modèle d'apprentissage automatique sont éloignées des valeurs réelles pendant la phase d'apprentissage. L'objectif de l'entraînement est de minimiser cette fonction de perte (sans la baisser à zéro qui serait du *overfit* extrème). Une fonction de perte est comme une mesure de combien vous êtes loin de la cible lorsque vous jouez aux fléchettes. Plus vous êtes proche du centre, plus votre score (ou perte) est faible.

Observer l'évolution d'un modèle en cours d'apprentissage (nous aborderons ce sujet plus tardivement) est crucial pour détérminer quand arrêter l'entrainement. En general cela se produit lorsque la fonction de perte a arrété de changer (le modèle n'apprends plus) et avant qu'elle soit trop faible (le modèle à overfit). Il n'y a pas de valeur fixes à observer, il faut itérer et essayer, determiner quels valeurs ont donnés des bons résultats et les queles il faut absolument éviter. Et justement, pour pouvoir déterminer ces attibut, il nous faut des bases objectives d'évaluation. Finalement, lorsque un modèle d'apprentissage automatique a été finalisé, il est temps de l'évaluer. La conception de modèles prédictifs est tellement complèxe, qu'il n'est pas envisageable de former un modèle de ML avec un seul tentatif. Il devient donc necessaire d'avoir à disposition des modes d'évaluation objectifs qui nous permettent de déterminer si notre nouvelle itaration est formallement meilleure que la précédente. Nous allons aborder l'idée de **validation** et de **test** d'un modèle et de bonnes pratiques liée à ces évaluation.

Lors de la constitution de votre *dataset d'apprentissage*, il est indispensable de reserver une partie de vos données pour deux phases décisives lors de l'apprentissage et l'évaluation d'un modèle; il s'agit des *sous ensebles de validation** et des **sous ensembles de test**. Il est forteent recommandé de reserver chaque élément issue du dataset d'apprentissage à un seul sous ensemble, lors de constitution de ces ensembles. Autrement dit, une donnée qui saur présent dans un ensemble ne saura pas présent dans les deux autres. Lors de la distribution de vos entrées issue du dataset d'apprentissage, il est crucial de faire attention à ne pas nuire à la *variance* ni au *biais* des différents sous ensembles, sous peine de se retouver soit avec un modèle ou des évaluations inexploitables.

- **Le Ensemble d'Entraînement** est le sous-ensemble de l'ensemble de données qui est utilisé pour entraîner un modèle d'apprentissage automatique. L'ensemble d'entraînement est comme les questions d'examen que vous utilisez pour étudier. Vous les utilisez pour apprendre et vous préparer à l'examen. **On lui reserve généralement 70-80% du dataset d'apprentissage** sans que cela soit une règle fixe.
- **Le Ensemble de Test** est le sous-ensemble de l'ensemble de données qui est utilisé pour évaluer la performance d'un modèle d'apprentissage automatique après l'entraînement. L'ensemble de test est comme l'examen final que vous passez après avoir étudié. Il vous donne une idée de ce que vous avez bien appris et de ce que vous devez encore travailler. **On lui reserve généralement 5-15% du dataset d'apprentissage** sans que cela soit une règle fixe.
- **Le Ensemble de Validation** est un sous-ensemble de l'ensemble de données qui est utilisé pour ajuster les hyperparamètres d'un modèle d'apprentissage automatique pendant l'entraînement. L'ensemble de validation est comme un quiz que vous prenez pendant que vous étudiez pour un examen. Il vous donne un retour d'information sur ce que vous avez bien compris et sur ce que vous devez revoir. **On lui reserve généralement 5-25% du dataset d'apprentissage** sans que cela soit une règle fixe.

Nous entrons dans un domaine extremement dynamique à présent, il existe pleins de framework d'entrainement mais ces concepts sont assez generaux pour être applicables partout. Generalement, le ensemble d'entrainement est passé par *batch* à la fonction d'apprentissage pendant toute une *époch*, enfin l'ensemble de validation est évalué pour adapter le taux d'apprentissage entre chaque *époch*. A la fin des repetitions qui auront été détérminé ou si vous decidez de stopper la progression de l'entrainement, l'ensemble de test est passé en *inférence* comme paramètre d'entrée et les *prédictions* sont comparés aux valeurs dans le enseble de test pour vous donner un socre d'éfficacité.

Enfin, il est important de rappeler que plus le nombre de paramètres qui sont en jeu dans vos prédiction est important, plus le nombre de issues de prédiction vous attendez de votre modèle, plus il sera complèxe et couteux (en terme de temps et d'effort) de l'entrainer et de l'évaluer autre que de l'exploiter. Ainsi, il est possible et même recommandé, d'appliquer les principes de "diviser pour mieux régner" (que nous avons abordé dans les leçons précédentes) lors de l'optimisation de problematiques complèxes. Vous l'aurez compris, nous avançons vers le sujet des **ensembles learning** qui promettent de combiner plusieurs modèles pour resoudre une tâche que chaque n'aurait pas pu accomplir.

**Le Ensemble Learning** est une stratégie d'apprentissage automatique qui combine plusieurs modèles pour obtenir de meilleures performances. Des exemples courants d'ensemble learning incluent le *bagging*, le *boosting* et le *stacking*. L'ensemble learning est comme demander l'opinion de plusieurs amis avant de prendre une décision. Chacun a une perspective différente et en combinant leurs opinions vis différentes stratégies, vous pouvez souvent prendre une meilleure décision.

Parmi les trategies de *ensemblig* les plus utilisés, nous pouvons citer:
- **Le Boosting** est une technique d'ensemble learning qui vise à créer un modèle fort à partir de plusieurs modèles faibles. Il entraîne chaque modèle de manière à corriger les erreurs du modèle précédent. Imaginez que vous essayez de préparer un plat complexe pour la première fois, disons un gâteau élaboré. Vous n'êtes pas un chef expert, mais vous avez plusieurs amis qui ont chacun une expertise limitée dans différents aspects de la pâtisserie. Vous essayez de faire le gâteau, mais il s'avère que la base n'est pas assez moelleuse. Vous notez cette erreur. Vous demandez à un ami qui est bon pour faire des bases de gâteaux moelleuses. En se basant sur votre première tentative, il ajuste la recette pour améliorer la base, mais maintenant, le glaçage n'est pas parfait. Un autre ami, qui est doué pour faire des glaçages, intervient. En tenant compte des ajustements précédents, il améliore le glaçage sans perturber la qualité de la base. Finalement, un dernier ami ajoute sa touche spéciale pour les décorations, en tenant compte de toutes les étapes précédentes. Dans cette analogie, chaque ami représente un "modèle faible" qui n'est expert que dans un aspect spécifique de la tâche. En travaillant ensemble, en séquence, et en apprenant des erreurs des tentatives précédentes, ils parviennent à créer un résultat final (le gâteau) qui est bien meilleur que ce que chacun aurait pu faire individuellement. C'est ainsi que fonctionne le boosting dans le machine learning : des modèles simples (amis) sont combinés de manière séquentielle, chacun corrigeant les erreurs du précédent, pour produire un modèle final robuste et performant.
- **Le Bagging (ou Bootstrap Aggregating)** est une autre technique d'ensemble learning qui entraîne plusieurs modèles indépendamment et combine leurs prédictions. Contrairement au boosting, le bagging utilise le vote majoritaire ou l'agrégation pour combiner les prédictions. Imaginez une compétition de talents où différents participants présentent leurs compétences diverses, comme chanter, danser, jouer d'un instrument, etc. Pour évaluer ces performances, un jury composé de plusieurs membres est présent. Chaque membre du jury a son propre ensemble de compétences, expériences et préférences personnelles: ils ont été entrainé chaq'un sur les même données mais avec des biais différent pour être chaque "experts" dans un domaine. Chaque membre du jury regarde les performances et donne son propre score de manière indépendante, sans être influencé par les autres juges. Une fois que tous les juges ont donné leur score, ces scores sont agrégés pour déterminer le gagnant. Cette agrégation peut être une moyenne des scores, ou selon un mode opératoire par fréquence (le score le plus fréquemment donné parmi les jury au candidat). C'est semblable à la façon dont le bagging combine les prédictions de plusieurs modèles par un vote majoritaire ou une moyenne. L'intérêt de ce jury diversifié est qu'il réduit le risque qu'un juge biaisé ou atypique affecte fortement le résultat final. De la même manière, le bagging réduit la variance et améliore la fiabilité des prédictions du modèle en combinant les résultats de plusieurs modèles indépendants. Ainsi, tout comme un jury diversifié dans une compétition de talents peut fournir une évaluation plus équilibrée et moins biaisée des performances, le bagging dans le machine learning combine les forces de plusieurs modèles pour obtenir des prédictions plus robustes et fiables.
- **Le Stacking** est une technique d'ensemble learning qui combine plusieurs modèles de classification ou de régression (appelés modèles de base) et utilise un autre modèle (appelé méta-modèle ou modèle de niveau supérieur) pour estimer la sortie basée sur les prédictions des modèles de base. En d'autres termes, les prédictions des modèles de base sont utilisées comme entrée pour le méta-modèle pour faire une prédiction finale. Imaginez que vous planifiez un voyage avec un groupe d'amis. Chacun de vos amis est responsable de rechercher et de proposer un itinéraire pour une partie spécifique du voyage, comme le transport, l'hébergement, les activités et la restauration. Chaque ami présente ses recommandations basées sur ses recherches et sa compréhension de la partie du voyage dont il est responsable. Ces recommandations sont comme les prédictions des modèles de base en stacking. Après avoir recueilli toutes ces recommandations, vous, en tant qu'organisateur principal du voyage, examinez toutes les suggestions pour élaborer l'itinéraire final. Vous prenez en compte la faisabilité, les préférences du groupe, et la cohérence globale du voyage. En vous basant sur les informations fournies par vos amis, vous faites des ajustements pour créer un itinéraire qui maximise l'expérience globale du voyage. C'est similaire au rôle du méta-modèle dans le stacking, qui utilise les prédictions des modèles de base pour faire une prédiction finale plus précise et adaptée. Dans cette analogie, chaque ami qui propose une partie de l'itinéraire est comme un modèle de base dans le stacking. Leur expertise individuelle apporte des perspectives différentes et utiles. Vous, en tant qu'organisateur principal, agissez comme le méta-modèle, en intégrant toutes ces perspectives pour prendre une décision finale éclairée. Cette approche combine les forces individuelles et minimise les faiblesses, aboutissant à un plan de voyage (ou une prédiction) bien équilibré et réfléchi.

**Avant de poursuivre**
Et voilà, nous avons terminé avec les terminologies communes. D'autres termes spécifiques aux différents cas seront abordés à l'occasion et seront expliquées avec les mêmes principes. Nous allons à présent aborder, par l'exemple, les trois familles de ML prédictives principales et expliquer leur fonctionnement.

## Algorithmes de Machine Learning Simples

Dans chaque leçon, nous aborderons la théorie derrière chaque algorithme, suivie d'une implémentation pratique en Python. Nous utiliserons du pure-python et son equivalent `scikit-learn` (une bibliothèque populaire pour le machine learning) pour construire et évaluer les modèles. Des exercices pratiques et des études de cas seront inclus pour renforcer l'apprentissage des concepts. Vous allez être encouragés à expérimenter avec différents paramètres et à analyser l'impact sur les performances du modèle.

### Leçon 1: Algorithmes de classification
- Introduction à la classification comme problème de machine learning
- Présentation des datasets de classification communément utilisés
- **k-Plus Proches Voisins (k-NN)**
  - Théorie et intuition derrière le k-NN
  - Implémentation en Python et scikit-learn
  - Évaluation de la performance et sélection de l'hyperparamètre \( k \)
- **Régression logistique**
  - Fondements de la régression logistique comme méthode de classification
  - Implémentation et interprétation des résultats
  - Application à un jeu de données et interprétation des coefficients
- **Machines à vecteurs de support (SVM)**
  - Principe et fonctionnement des SVM
  - Utilisation des SVM pour la classification linéaire et non linéaire
  - Choix des hyperparamètres et utilisation de noyaux pour des décisions non linéaires

### Leçon 2: Algorithmes de régression
- Introduction à la régression dans le contexte du machine learning
- **Régression linéaire**
  - Concepts de base de la régression linéaire
  - Implémentation en Python et scikit-learn
  - Interprétation des coefficients et mesure de la performance
- **Régression polynomiale**
  - Extension de la régression linéaire à la régression polynomiale
  - Comment transformer les features pour la régression polynomiale
  - Risques de surajustement (overfitting) et comment les éviter

### Leçon 3: Algorithmes de clustering
- Introduction au clustering et à ses applications
- **k-Moyennes (k-Means)**
  - Algorithme de k-Means et son utilisation pour le clustering
  - Implémentation en Python et scikit-learn
  - Sélection du nombre de clusters et interprétation des résultats
- **Clustering hiérarchique**
  - Comprendre le clustering hiérarchique et son fonctionnement
  - Implémentation en Python et visualisation des dendrogrammes
  - Découpage (cutting) du dendrogramme pour déterminer les clusters
